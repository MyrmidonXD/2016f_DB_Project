options{  static = true;  DEBUG_PARSER = false;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)// importsimport java.util.*;/* My Custom Classes *///import MyInterpreter;//import DBType;public class SimpleDBMSParser{  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE 	 = 2;  public static final int PRINT_DESC         = 3;  public static final int PRINT_SHOW_TABLES  = 4;  public static final int PRINT_SELECT		 = 5;  public static final int PRINT_INSERT		 = 6;  public static final int PRINT_DELETE		 = 7;    public static void main(String args[]) throws ParseException  {    MyInterpreter interpreter = MyInterpreter.getInstance();        SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    System.out.print("DB_2014-11111> ");    while (true)    {      try      {        parser.command();      }      catch (Throwable e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);      }    }  }  public static void printMessage(int q)  {        switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      /*      case PRINT_CREATE_TABLE:      	System.out.println("\'CREATE TABLE\' requested");      	break;  	  case PRINT_DROP_TABLE:      	System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC:      	System.out.println("\'DESC\' requested");      	break;      case PRINT_SHOW_TABLES:      	System.out.println("\'SHOW TABLES\' requested");      	break;      case PRINT_SELECT:      	System.out.println("\'SELECT\' requested");      	break;      case PRINT_INSERT:      	System.out.println("\'INSERT\' requested");      	break;      case PRINT_DELETE:      	System.out.println("\'DELETE\' requested");      	break;      */    }        System.out.print("DB_2014-11111> ");  }}PARSER_END(SimpleDBMSParser)SKIP : { " " | "\r" | "\t" | "\n" }TOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE : "create" >| < TABLE : "table" >| < NOT  : "not" >| < NULL : "null" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >| < DROP : "drop" > /* Keywords for [3. DROP TABLE / DESC / SHOW TABLES] */| < DESC : "desc" >| < SHOW : "show" >| < TABLES : "tables" >| < SELECT : "select" > /* Keywords for [4. SELECT ] */| < FROM : "from" >| < AS : "as" >| < WHERE : "where" >| < IS : "is" >| < AND : "and" >| < OR : "or" >| < INSERT : "insert" > /* Keywords for [5. INSERT / DELETE] */| < INTO : "into" >| < VALUES : "values" >| < DELETE : "delete" >}TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>| < SIGN : "+" | "-" >| < DIGIT : [ "0"-"9" ] >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < PERIOD : "." >| < ASTERISK : "*" >| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >| < NN : < DIGIT > < DIGIT > >| < QUOTE : "'" >| < NON_QUOTE_SPECIAL_CHARACTERS : [ "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "-", "_", "+", "=", "|", "\\", "`", "~", ":", ";", "?", "/", ">", "<", ".", ",",  "{", "}", "[", "]" ] >| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | " " >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > > }void command() :{}{  queryList()| (    < EXIT >    < SEMICOLON >    (	    {	      MyInterpreter.getInstance().terminate();	      System.exit(0);	    }  	)  ) }void queryList() :{  int q;}{  (    q = query()    {  	  printMessage(q);  	}  )+}int query() :{  int q;}{  (    createTableQuery()    {      q = PRINT_CREATE_TABLE;    }  | dropTableQuery()  	{  	  q = PRINT_DROP_TABLE;  	}  | descQuery()    {      q = PRINT_DESC;    }  | showTablesQuery()    {      q = PRINT_SHOW_TABLES;    }  | selectQuery()  	{  	  q = PRINT_SELECT;  	}  | insertQuery()  	{  	  q = PRINT_INSERT;  	}  | deleteQuery()  	{  	  q = PRINT_DELETE;  	}  )  (    {      return q;    }  )}void createTableQuery() :{  String _tableName;  MyInterpreter.getInstance().createTable_Initialize();}{  < CREATE >  < TABLE >  _tableName = tableName()  tableElementList()  < SEMICOLON >  {    try    {      MyInterpreter.getInstance().createTable(_tableName);    }    catch(DBError e)    {        System.out.println(e.getMessage());    }  }}void tableElementList() :{}{  < LEFT_PAREN >  tableElement()  (    < COMMA >    tableElement()  )*  < RIGHT_PAREN >}void tableElement() :{}{  columnDefinition()| tableConstraintDefinition()}void columnDefinition() :{  String colName;  String typeStr;  int typeVal;  DBType dbType;  boolean isNotNull = false;}{  colName = columnName()  dbType = dataType()  (    < NOT >    < NULL >    (      {        isNotNull = true;      }    )  )?  (    {      if(dbType.type == DBType.DBTypeSpecifier.DB_INT) {       	typeStr = "int";      	typeVal = -1;      }      else if(dbType.type == DBType.DBTypeSpecifier.DB_DATE) {        typeStr = "date";        typeVal = -1;      }      else {        typeStr = "char";        typeVal = dbType.length;      }      MyInterpreter.getInstance().createTable_EnqueueColumn(colName, typeStr, typeVal, isNotNull);    }  )}void tableConstraintDefinition() :{}{  primaryKeyConstraint()| referentialConstraint()}void primaryKeyConstraint() :{  ArrayList<String> colList;}{  < PRIMARY >  < KEY >   colList= columnNameList()  (    {      MyInterpreter.getInstance().createTable_EnqueuePK(colList);    }  )}void referentialConstraint() :{  ArrayList<String> refingColList;  String refedTableName;  ArrayList<String> refedColList;}{  < FOREIGN >  < KEY >  refingColList = columnNameList()  < REFERENCES >  refedTableName = tableName()  refedColList = columnNameList()  (    {      MyInterpreter.getInstance().createTable_EnqueueFK(refingColList, refedTableName, refedColList);    }  )}ArrayList<String> columnNameList() :{  ArrayList<String> _colNameList = new ArrayList<String>();  String _nextColumn;}{  < LEFT_PAREN >  _nextColumn = columnName()  (    {       _colNameList.add(_nextColumn);  	}  )  (    < COMMA >    _nextColumn = columnName()    (      {     	_colNameList.add(_nextColumn);      }  	)  )*  < RIGHT_PAREN >  (    {      return _colNameList;    }  )}DBType dataType() :{  Token _t;  DBType _dt;}{  (  	  < INT >	  (	    {	      _dt = new DBType("int");      	    }	  )	|	  (	    < CHAR >	    < LEFT_PAREN >	    _t = < INT_VALUE >	    < RIGHT_PAREN >	  )	  (	    {	      _dt = new DBType("char", Integer.parseInt(_t.toString()));	    }	  )	|	  < DATE >	  (	    {	      _dt = new DBType("date");	    }	  )  )  (    {      return _dt;    }  )}String tableName() :{  Token _tableName;}{  _tableName = < LEGAL_IDENTIFIER >  (    {      return _tableName.toString().toLowerCase();          }  )}String columnName() :{  Token _colName;}{  _colName = < LEGAL_IDENTIFIER >  (    {      return _colName.toString().toLowerCase();          }  )}//--------- [ 3. DROP TABLE / DESC / SHOW TABLES ] ---------//void dropTableQuery() :{  String _tableName;}{  < DROP >  < TABLE >  _tableName = tableName()  < SEMICOLON >  {    try    {      	MyInterpreter.getInstance().dropTable(_tableName);  	}  	catch(DBError e)    {        System.out.println(e.getMessage());    }  }}void descQuery() :{  String _tableName;}{  < DESC >  _tableName = tableName()  < SEMICOLON >  {    try    {    	MyInterpreter.getInstance().desc(_tableName);    }    catch(DBError e)    {        System.out.println(e.getMessage());    }  }}void showTablesQuery() :{}{  < SHOW >  < TABLES >  < SEMICOLON >  {    try    {     	MyInterpreter.getInstance().showTables();    }    catch(DBError e)    {        System.out.println(e.getMessage());    }  }}//--------- [ 4. SELECT ] ---------//void selectQuery() :{  ArrayList<String> tblList = new ArrayList<String>();  ArrayList<String> colList = new ArrayList<String>();  ArrayList<String> aliasList = new ArrayList<String>();  ArrayList<FromClause> fromContainer = new ArrayList<FromClause>();  BoolTree where = null;  MyInterpreter.getInstance().initSelDel();}{  < SELECT >  colList = selectList(tblList, colList, aliasList)  where = tableExpression(fromContainer)  < SEMICOLON >  {    try    {      if(MyInterpreter.getInstance().isExecutable()) {        MyInterpreter.getInstance().select(colList, tblList, aliasList, fromContainer.get(0), where);      }    }    catch(DBError e)    {        System.out.println(e.getMessage());    }  }}ArrayList<String> selectList(ArrayList<String> tblList, ArrayList<String> colList, ArrayList<String> aliasList) :{}{  < ASTERISK >  {    return null;  }| (    selectedColumn(tblList, colList, aliasList)    (      < COMMA >      selectedColumn(tblList, colList, aliasList)    )*  )  {    return colList;  }}void selectedColumn(ArrayList<String> tblList, ArrayList<String> colList, ArrayList<String> aliasList) :{  String tblName = null;  String colName = null;  String aliasName = null;}{  (    LOOKAHEAD(2)    tblName = tableName()    < PERIOD >  )?  colName = columnName()  (    < AS >    aliasName = columnName()  )?  {    tblList.add(tblName);    colList.add(colName);    aliasList.add(aliasName);  }}BoolTree tableExpression(ArrayList<FromClause> fromContainer) :{  BoolTree where = null;  FromClause from;}{  from = fromClause()  (    where = whereClause(from)  )?  {    fromContainer.add(from);    return where;  }}FromClause fromClause() :{  ArrayList<String> tblList = new ArrayList<String>();  ArrayList<String> aliasList = new ArrayList<String>();  FromClause from = null;}{  < FROM >  tableReferenceList(tblList, aliasList)  {    try    {       from = new FromClause(tblList, aliasList);    }    catch (DBError e)    {      if(MyInterpreter.getInstance().isExecutable()) {        System.out.println(e.getMessage());        MyInterpreter.getInstance().setExceptionOccured();      }    }    finally    {       return from;    }  }}void tableReferenceList(ArrayList<String> tblList, ArrayList<String> aliasList) :{}{  referedTable(tblList, aliasList)  (    < COMMA >    referedTable(tblList, aliasList)  )*}void referedTable(ArrayList<String> tblList, ArrayList<String> aliasList) :{  String tblName = null;  String aliasName = null;}{  tblName = tableName()  (    < AS >    aliasName = tableName()  )?  {    tblList.add(tblName);    aliasList.add(aliasName);  } }BoolTree whereClause(FromClause from) :{  BoolTree where;}{  < WHERE >  where = booleanValueExpression(from)  {    return where;  }}BoolTree booleanValueExpression(FromClause from) :{  ArrayList<BoolTree> termList = new ArrayList<BoolTree>();  BoolTree currTerm, root;}{  currTerm = booleanTerm(from)  {    termList.add(currTerm);  }  (    < OR >    currTerm = booleanTerm(from)    {      termList.add(currTerm);    }  )*  {    int lastIdx = termList.size() - 1;    root = termList.get(lastIdx);    for(int i = lastIdx - 1; i >= 0; i--) {      BoolTree nextRoot = new BoolTree(BoolTreeOperator.BT_OR);      nextRoot.setLeftChild(termList.get(i));      nextRoot.setRightChild(root);      root = nextRoot;    }    return root;  }}BoolTree booleanTerm(FromClause from) :{  ArrayList<BoolTree> factorList = new ArrayList<BoolTree>();  BoolTree currFactor, root;}{  currFactor = booleanFactor(from)  {    factorList.add(currFactor);  }  (    < AND >    currFactor = booleanFactor(from)    {      factorList.add(currFactor);    }  )*  {    int lastIdx = factorList.size() - 1;    root = factorList.get(lastIdx);    for(int i = lastIdx - 1; i >= 0; i--) {      BoolTree nextRoot = new BoolTree(BoolTreeOperator.BT_AND);      nextRoot.setLeftChild(factorList.get(i));      nextRoot.setRightChild(root);      root = nextRoot;    }    return root;  }}BoolTree booleanFactor(FromClause from) :{  boolean _isNot = false;  BoolTree root;}{  (    < NOT >    {      _isNot = true;    }  )?  root = booleanTest(from)  {    if(_isNot) root.setNot();    return root;  }}BoolTree booleanTest(FromClause from) :{  BoolTree root;}{  (    root = predicate(from)	| root = parenthesizedBooleanExpression(from)  )  {    return root;  }}BoolTree parenthesizedBooleanExpression(FromClause from) :{  BoolTree root;}{  < LEFT_PAREN >  root = booleanValueExpression(from)  < RIGHT_PAREN >  {    return root;  }}BoolTree predicate(FromClause from) :{  BoolTree root;}{  (    LOOKAHEAD(4)	root = comparisonPredicate(from)  | LOOKAHEAD(4)	root = nullPredicate(from)  )  {    return root;  }}BoolTree comparisonPredicate(FromClause from) :{  ArrayList<String> leftColRef = new ArrayList<String>(); // : { tableName, columnName }  ArrayList<String> rightColRef = new ArrayList<String>(); // : { tableName, columnName }  DBValue leftConst = null;  DBValue rightConst = null;  Token _t;  String _opStr;  CompOperator _op;  CompPredicate _predicate = null;  int leftIdx = -1;  int rightIdx = -1;}{  leftConst = compOperand(leftColRef)  _t = < COMP_OP >  rightConst = compOperand(rightColRef)  {    _opStr = _t.toString();    if(_opStr.equals(">"))      _op = CompOperator.OP_GT;    else if(_opStr.equals("<"))      _op = CompOperator.OP_LT;    else if(_opStr.equals(">="))      _op = CompOperator.OP_GE;    else if(_opStr.equals("<="))      _op = CompOperator.OP_LE;    else if(_opStr.equals("="))      _op = CompOperator.OP_EQ;    else      _op = CompOperator.OP_NEQ;    try    { 	    if(leftConst == null) {	      leftIdx = from.referenceQuery(leftColRef.get(0), leftColRef.get(1));	    }	    if(rightConst == null) {	      rightIdx = from.referenceQuery(rightColRef.get(0), rightColRef.get(1));	    }	    _predicate = new CompPredicate(leftIdx, _op, rightIdx);	    _predicate.setLeftConstOperand(leftConst);	    _predicate.setRightConstOperand(rightConst);    }    catch(DBError e)    {      if(MyInterpreter.getInstance().isExecutable()) {        System.out.println(e.getMessage());        MyInterpreter.getInstance().setExceptionOccured();      }    }    finally    {       return _predicate;    }  }}DBValue compOperand(ArrayList<String> colRef) :{  DBValue constOperand = null;  String tblName = null;  String colName = null;}{  constOperand = comparableValue()  {    return constOperand;  }|(  	LOOKAHEAD(2)  	tblName = tableName()  	< PERIOD > )? colName = columnName() {   colRef.add(tblName);   colRef.add(colName);   return null; }}DBValue comparableValue() :{  Token _t;  String[] _ymd;  String _cstr;}{  _t = < INT_VALUE >  {    return new DBValue(Integer.parseInt(_t.toString()));  }| _t = < CHAR_STRING >  {    _cstr = _t.toString();    _cstr = _cstr.substring(1, _cstr.length() - 1);    return new DBValue(_cstr);  }| _t = < DATE_VALUE >  {    _ymd = _t.toString().split("-");    return new DBValue(Integer.parseInt(_ymd[0]), Integer.parseInt(_ymd[1]), Integer.parseInt(_ymd[2]));  }}BoolTree nullPredicate(FromClause from) :{  String tblName = null;  String colName = null;  boolean isNull;  int colIdx;  NullPredicate _predicate = null;}{  (    LOOKAHEAD(2)    tblName = tableName()    < PERIOD >  )?  colName = columnName()  isNull = nullOperation()  {    try    {      colIdx = from.referenceQuery(tblName, colName);      _predicate = new NullPredicate(colIdx, isNull);    }    catch(DBError e)    {      if(MyInterpreter.getInstance().isExecutable()) {        System.out.println(e.getMessage());        MyInterpreter.getInstance().setExceptionOccured();      }    }    finally    {      return _predicate;    }  }}boolean nullOperation() :{  boolean isNull = true;}{  < IS >  (    < NOT >    {      isNull = false;    }  )?  < NULL >  {    return isNull;  }}//--------- [ 5. INSERT / DELETE ] ---------//void insertQuery() :{  String _tableName;  ArrayList<String> _colList = new ArrayList<String>();  ArrayList<DBValue> _valList = new ArrayList<DBValue>();}{  < INSERT >  < INTO >  _tableName = tableName()  insertColumnsAndSource(_colList, _valList)  < SEMICOLON >  {    try    {      MyInterpreter.getInstance().insertInto(_tableName, _colList, _valList);    }    catch(DBError e)    {      System.out.println(e.getMessage());    }  }}void insertColumnsAndSource(ArrayList<String> colList, ArrayList<DBValue> valList) :{  ArrayList<String> _colListReturned;}{  (    _colListReturned = columnNameList()    {      colList.addAll(_colListReturned);    }  )?  valueList(valList)}void valueList(ArrayList<DBValue> valList) :{  DBValue _currVal;}{  < VALUES >  < LEFT_PAREN >  _currVal = value()  {    valList.add(_currVal);  }  (    < COMMA >    _currVal = value()    {      valList.add(_currVal);    }  )*  < RIGHT_PAREN >}DBValue value() :{  DBValue _res;}{  < NULL >  {    return new DBValue();  }| _res = comparableValue()  {    return _res;    }}void deleteQuery() :{  String _tableName;  FromClause from = null;  ArrayList<String> tblList = new ArrayList<String>();  ArrayList<String> aliasList = new ArrayList<String>();  aliasList.add(null);  BoolTree where = null;  MyInterpreter.getInstance().initSelDel();}{  < DELETE >  < FROM >  _tableName = tableName()  {    try    {      MyInterpreter.getInstance().delete_tableExistenceCheck(_tableName);      tblList.add(_tableName);      from = new FromClause(tblList, aliasList);    }    catch(DBError e)    {      if(MyInterpreter.getInstance().isExecutable()) {        System.out.println(e.getMessage());        MyInterpreter.getInstance().setExceptionOccured();      }    }  }  (    where = whereClause(from)  )?  < SEMICOLON >  {    try    {      if(MyInterpreter.getInstance().isExecutable()) {        MyInterpreter.getInstance().delete(_tableName, where);      }    }    catch(DBError e)    {        System.out.println(e.getMessage());    }  }}